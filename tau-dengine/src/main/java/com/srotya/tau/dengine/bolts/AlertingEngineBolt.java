/**
 * Copyright 2016 Symantec Corporation.
 * 
 * Licensed under the Apache License, Version 2.0 (the “License”); 
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.srotya.tau.dengine.bolts;

import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.apache.velocity.Template;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.RuntimeSingleton;
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.velocity.runtime.parser.node.SimpleNode;

import com.google.gson.Gson;
import com.srotya.tau.dengine.Constants;
import com.srotya.tau.dengine.StormContextUtil;
import com.srotya.tau.dengine.UnifiedFactory;
import com.srotya.tau.dengine.Utils;
import com.srotya.tau.wraith.Event;
import com.srotya.tau.wraith.actions.Action;
import com.srotya.tau.wraith.actions.alerts.Alert;
import com.srotya.tau.wraith.actions.alerts.AlertAction;
import com.srotya.tau.wraith.actions.alerts.AlertingEngine;
import com.srotya.tau.wraith.rules.Rule;
import com.srotya.tau.wraith.rules.RuleCommand;
import com.srotya.tau.wraith.rules.RuleSerializer;
import com.srotya.tau.wraith.rules.SimpleRule;
import com.srotya.tau.wraith.store.RulesStore;
import com.srotya.tau.wraith.store.StoreFactory;

import backtype.storm.task.OutputCollector;
import backtype.storm.task.TopologyContext;
import backtype.storm.topology.OutputFieldsDeclarer;
import backtype.storm.topology.base.BaseRichBolt;
import backtype.storm.tuple.Fields;
import backtype.storm.tuple.Tuple;
import backtype.storm.tuple.Values;

/**
 * {@link AlertingEngine} implementation in form of a Storm {@link BaseRichBolt}
 * . This bolt is responsible for converting an alert generated by
 * RulesEngineBolt to an actual user facing alert by materializing the Velocity
 * template body of the actual alert configuration.
 * 
 * @author ambud_sharma
 */
public class AlertingEngineBolt extends BaseRichBolt implements AlertingEngine {

	private static final long serialVersionUID = 1L;
	private static final Logger logger = Logger.getLogger(AlertingEngineBolt.class.getName());
	private transient Map<String, Template> templateMap;
	private transient Map<Short, String> ruleMap;
	private transient OutputCollector collector;
	private transient StoreFactory storeFactory;
	private transient RuntimeServices runtimeServices;
	private transient Gson gson;

	@SuppressWarnings({ "rawtypes", "unchecked" })
	@Override
	public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) {
		this.collector = collector;
		this.gson = new Gson();
		this.templateMap = new HashMap<>();
		this.ruleMap = new HashMap<>();
		this.storeFactory = new UnifiedFactory();
		this.runtimeServices = RuntimeSingleton.getRuntimeServices();
		try {
			initializeTemplates(stormConf);
		} catch (Exception e) {
			logger.log(Level.SEVERE, "Failed to initialize rule/templates for alerts", e);
			throw new RuntimeException(e);
		}
		logger.info("Alerting Engine Bolt initialized");
	}

	@Override
	public void execute(Tuple tuple) {
		if (Utils.isRuleSyncTuple(tuple)) {
			logger.info("Attempting to apply rule update:" + tuple.getValueByField(Constants.FIELD_RULE_CONTENT));
			RuleCommand ruleCommand = (RuleCommand) tuple.getValueByField(Constants.FIELD_RULE_CONTENT);
			try {
				logger.info("Received rule tuple with rule content:" + ruleCommand.getRuleContent());
				updateRule(ruleCommand.getRuleGroup(), ruleCommand.getRuleContent(), ruleCommand.isDelete());
				logger.info("Applied rule update with rule content:" + ruleCommand.getRuleContent());
			} catch (Exception e) {
				// failed to update rule
				System.err.println("Failed to apply rule update:" + e.getMessage() + "\t"
						+ tuple.getValueByField(Constants.FIELD_RULE_CONTENT));
				StormContextUtil.emitErrorTuple(collector, tuple, AlertingEngineBolt.class, tuple.toString(),
						"Failed to apply rule update", e);
			}
		} else {
			Alert alertResult = null;
			alertResult = materialize((Event) tuple.getValueByField(Constants.FIELD_EVENT),
					tuple.getStringByField(Constants.FIELD_RULE_GROUP),
					tuple.getShortByField(Constants.FIELD_RULE_ID),
					tuple.getShortByField(Constants.FIELD_ACTION_ID),
					tuple.getStringByField(Constants.FIELD_ALERT_TARGET),
					tuple.getStringByField(Constants.FIELD_ALERT_MEDIA),
					tuple.getLongByField(Constants.FIELD_TIMESTAMP));
			if (alertResult == null) {
				String eventJson = gson.toJson(((Event) tuple.getValueByField(Constants.FIELD_EVENT)).getHeaders());
				StormContextUtil.emitErrorTuple(collector, tuple, AlertingEngineBolt.class,
						"Failed to materialize alert due to missing template for rule:"
								+ tuple.getShortByField(Constants.FIELD_RULE_ID) + ",action:"
								+ tuple.getShortByField(Constants.FIELD_ACTION_ID),
						eventJson, null);
			} else {
				collector.emit(Constants.ALERT_STREAM_ID, tuple,
						new Values(alertResult.getTarget(), alertResult.getMedia(), alertResult.getBody(),
								gson.toJson(alertResult), tuple.getShortByField(Constants.FIELD_RULE_ID),
								tuple.getShortByField(Constants.FIELD_ACTION_ID)));
			}
		}
		collector.ack(tuple);
	}

	@Override
	public void declareOutputFields(OutputFieldsDeclarer declarer) {
		declarer.declareStream(Constants.ALERT_STREAM_ID,
				new Fields(Constants.FIELD_ALERT_TARGET, Constants.FIELD_ALERT_MEDIA, Constants.FIELD_ALERT_BODY,
						Constants.FIELD_ALERT, Constants.FIELD_RULE_ID, Constants.FIELD_ACTION_ID));
		StormContextUtil.declareErrorStream(declarer);
	}

	@Override
	public Alert materialize(Event event, String ruleGroup, short ruleId, short actionId, String target, String media,
			long timestamp) {
		Alert alert = materialize(event, ruleId, actionId, target, media, timestamp);
		if (alert != null) {
			alert.setRuleGroup(ruleGroup);
		}
		return alert;
	}

	@Override
	public Alert materialize(Event event, short ruleId, short actionId, String target, String media, long timestamp) {
		Alert alert = new Alert();
		String rule = ruleMap.get(ruleId);
		if (rule != null) {
			String key = Utils.combineRuleActionId(ruleId, actionId);
			Template template = templateMap.get(key);
			if (template != null) {
				VelocityContext ctx = new VelocityContext();
				for (Entry<String, Object> entry : event.getHeaders().entrySet()) {
					ctx.put(entry.getKey(), entry.getValue());
				}
				StringWriter writer = new StringWriter(1000);
				template.merge(ctx, writer);
				alert.setBody(writer.toString());
				alert.setSubject(rule);
				alert.setTarget(target);
				alert.setMedia(media);
				alert.setId(ruleId);
				alert.setTimestamp(timestamp);
				return alert;
			} else {
				return null;
			}
		} else {
			return null;
		}
	}

	@Override
	public void updateRule(String ruleGroup, String ruleJson, boolean delete) {
		SimpleRule rule = RuleSerializer.deserializeJSONStringToRule(ruleJson);
		ruleMap.put(rule.getRuleId(), rule.getName());
		try {
			buildTemplateMapForActions(rule);
		} catch (ParseException e) {
			logger.log(Level.SEVERE, "Rule alert template error", e);
		}
	}

	/**
	 * Connects to the {@link RulesStore} and fetches all the {@link Rule}s,
	 * only {@link Rule}s with {@link AlertAction} are materialized into
	 * Velocity {@link Template}
	 * 
	 * @param conf
	 * @throws Exception
	 */
	public void initializeTemplates(Map<String, String> conf) throws Exception {
		Properties props = new Properties();
		props.setProperty("runtime.log.logsystem.class", "org.apache.velocity.runtime.log.NullLogChute");

		Velocity.init(props);
		RulesStore store = null;
		try {
			store = storeFactory.getRulesStore(conf.get(Constants.RSTORE_TYPE), conf);
		} catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {
			throw e;
		}
		try {
			store.connect();
			Map<String, Map<Short, Rule>> listRules = store.listGroupedRules();
			logger.info("Loaded:" + listRules.size() + " rules from the store");
			for (Map<Short, Rule> rules : listRules.values()) {
				for (Entry<Short, Rule> entry : rules.entrySet()) {
					Rule rule = entry.getValue();
					ruleMap.put(rule.getRuleId(), rule.getName());
					System.err.println(rule.toString());
					buildTemplateMapForActions(rule);
				}
			}
			store.disconnect();
		} catch (IOException e) {
			throw e;
		}
	}

	/**
	 * Builds {@link Template}s for each {@link Action} of {@link AlertAction}
	 * type for a given {@link Rule} and inserts it into the internal
	 * {@link Map} used for lookups.
	 * 
	 * @param rule
	 * @throws ParseException
	 */
	public void buildTemplateMapForActions(Rule rule) throws ParseException {
		if (rule.getActions() != null) {
			for (Action action : rule.getActions()) {
				if (action instanceof AlertAction) {
					AlertAction alertAction = (AlertAction) action;
					StringReader reader = new StringReader(alertAction.getBody());
					SimpleNode node = runtimeServices.parse(reader, rule.getName());
					Template template = new Template();
					template.setRuntimeServices(runtimeServices);
					template.setData(node);
					template.initDocument();
					templateMap.put(Utils.combineRuleActionId(rule.getRuleId(), action.getActionId()), template);
				}
			}
		} else {
			logger.log(Level.SEVERE, "Bad rule with no actions:" + rule.toString());
		}
	}

	/**
	 * @return the templateMap
	 */
	protected Map<String, Template> getTemplateMap() {
		return templateMap;
	}

	/**
	 * @return the ruleMap
	 */
	protected Map<Short, String> getRuleMap() {
		return ruleMap;
	}

	/**
	 * @return the storeFactory
	 */
	protected StoreFactory getStoreFactory() {
		return storeFactory;
	}

}